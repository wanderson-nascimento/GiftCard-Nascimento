"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryClient = void 0;
exports.NewTelemetryClient = NewTelemetryClient;
const tslib_1 = require("tslib");
const discovery_1 = require("../discovery");
const logs = tslib_1.__importStar(require("../logs"));
const traces = tslib_1.__importStar(require("../traces"));
const metrics = tslib_1.__importStar(require("../metrics"));
const processors_1 = require("../processors");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const instrumentation_2 = require("../instrumentation");
class TelemetryClient {
    constructor(clientName, serviceName, resource) {
        this.resource = resource;
        this.clientName = clientName;
        this.serviceName = serviceName;
    }
    async newLogsClient(config) {
        const fullConfig = { ...config, resource: this.resource };
        try {
            this.logClient = await logs.NewClient(fullConfig, this.serviceName, this.clientName);
            return this.logClient;
        }
        catch (error) {
            throw error;
        }
    }
    async newTracesClient(config) {
        const fullConfig = {
            ...config,
            resource: this.resource,
            propagateContext: config.propagateContext !== undefined ? config.propagateContext : true,
            setGlobalPropagator: config.setGlobalPropagator !== undefined ? config.setGlobalPropagator : false,
            useDefaultInstrumentations: config.useDefaultInstrumentations !== undefined ? config.useDefaultInstrumentations : true,
        };
        try {
            if (!fullConfig.processors) {
                fullConfig.processors = [];
            }
            const hasVtexProcessor = fullConfig.processors.some(p => p instanceof processors_1.VtexAttrs.VtexAttributesSpanProcessor);
            if (!hasVtexProcessor && fullConfig.exporter?.traceExporter) {
                const traceExporter = fullConfig.exporter.traceExporter();
                const batchProcessor = new sdk_trace_base_1.BatchSpanProcessor(traceExporter);
                const vtexProcessor = new processors_1.VtexAttrs.VtexAttributesSpanProcessor(batchProcessor);
                fullConfig.processors.push(vtexProcessor);
            }
            const extendedConfig = {
                ...fullConfig,
            };
            const client = await traces.NewClient(extendedConfig, this.serviceName, this.clientName);
            if (fullConfig.useDefaultInstrumentations) {
                this.setInstrumentations([
                    new instrumentation_2.NetInstrumentation(),
                    new instrumentation_2.HttpInstrumentation()
                ]);
            }
            this.traceClient = client;
            return client;
        }
        catch (error) {
            throw error;
        }
    }
    async newMetricsClient(config) {
        const fullConfig = {
            ...config,
            resource: this.resource
        };
        try {
            const client = await metrics.NewClient(fullConfig, this.serviceName, this.clientName);
            this.metricsClient = client;
            return client;
        }
        catch (error) {
            throw error;
        }
    }
    setInstrumentations(instrumentations) {
        try {
            if (!this.traceClient && !this.logClient && !this.metricsClient) {
                throw new Error("There is no client to set instrumentations");
            }
            (0, instrumentation_1.registerInstrumentations)({
                instrumentations,
                tracerProvider: this.traceClient?.getProvider(),
                loggerProvider: this.logClient?.getProvider(),
                meterProvider: this.metricsClient?.getProvider()
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.TelemetryClient = TelemetryClient;
async function NewTelemetryClient(clientName, serviceName, options = {}) {
    try {
        const resourceConfig = {
            clientName,
            serviceName,
            environment: options.environment,
            envMappings: options.envMappings,
            customAttributesFile: options.customAttributesFile,
            additionalAttrs: options.additionalAttrs,
            disableCloudDetect: options.disableCloudDetect,
            disableK8sDetect: options.disableK8sDetect
        };
        const resource = await (0, discovery_1.configureDefaults)(resourceConfig);
        return new TelemetryClient(clientName, serviceName, resource);
    }
    catch (error) {
        throw new Error(`Failed to create telemetry client: ${error.message}`);
    }
}
//# sourceMappingURL=client.js.map