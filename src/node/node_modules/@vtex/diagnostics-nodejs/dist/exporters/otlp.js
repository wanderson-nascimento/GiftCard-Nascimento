"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OTLPExporter = void 0;
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const exporter_logs_otlp_grpc_1 = require("@opentelemetry/exporter-logs-otlp-grpc");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const exporter_trace_otlp_grpc_1 = require("@opentelemetry/exporter-trace-otlp-grpc");
const exporter_metrics_otlp_http_1 = require("@opentelemetry/exporter-metrics-otlp-http");
const exporter_metrics_otlp_grpc_1 = require("@opentelemetry/exporter-metrics-otlp-grpc");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const exporters_1 = require("../types/exporters");
class OTLPExporter {
    constructor(config) {
        this.config = config;
    }
    async initialize() {
        this.config.validate();
        switch (this.config.telemetryType) {
            case exporters_1.TelemetryType.METRICS:
                await this.initializeMetrics();
                break;
            case exporters_1.TelemetryType.LOGS:
                await this.initializeLogs();
                break;
            case exporters_1.TelemetryType.TRACES:
                await this.initializeTraces();
                break;
            default:
                throw new Error(`Unsupported telemetry type: ${this.config.telemetryType}`);
        }
    }
    async initializeMetrics() {
        if (this.config.options.protocol === 'grpc') {
            this.metricExporterInstance = new exporter_metrics_otlp_grpc_1.OTLPMetricExporter({
                url: this.config.options.endpoint || 'localhost:4317',
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {},
            });
        }
        else {
            const url = this.buildUrl(this.config.options.endpoint || 'http://localhost:4318', this.config.options.path || '/v1/metrics');
            this.metricExporterInstance = new exporter_metrics_otlp_http_1.OTLPMetricExporter({
                url: url,
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {}
            });
        }
        this.metricReaderInstance = new sdk_metrics_1.PeriodicExportingMetricReader({
            exporter: this.metricExporterInstance,
            exportIntervalMillis: (this.config.options.interval || 10) * 1000,
            exportTimeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
        });
    }
    async initializeLogs() {
        if (this.config.options.protocol === 'grpc') {
            this.logExporterInstance = new exporter_logs_otlp_grpc_1.OTLPLogExporter({
                url: this.config.options.endpoint || 'localhost:4317',
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {}
            });
        }
        else {
            const url = this.buildUrl(this.config.options.endpoint || 'http://localhost:4318', this.config.options.path || '/v1/logs');
            this.logExporterInstance = new exporter_logs_otlp_http_1.OTLPLogExporter({
                url: url,
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {}
            });
        }
        this.logProcessorInstance = new sdk_logs_1.BatchLogRecordProcessor(this.logExporterInstance, {
            maxExportBatchSize: 10,
            scheduledDelayMillis: 500,
            exportTimeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
            maxQueueSize: 1000
        });
    }
    async initializeTraces() {
        if (this.config.options.protocol === 'grpc') {
            this.traceExporterInstance = new exporter_trace_otlp_grpc_1.OTLPTraceExporter({
                url: this.config.options.endpoint || 'localhost:4317',
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {}
            });
        }
        else {
            const url = this.buildUrl(this.config.options.endpoint || 'http://localhost:4318', this.config.options.path || '/v1/traces');
            this.traceExporterInstance = new exporter_trace_otlp_http_1.OTLPTraceExporter({
                url: url,
                timeoutMillis: (this.config.options.timeoutSeconds || 10) * 1000,
                headers: this.config.options.headers || {}
            });
        }
    }
    buildUrl(endpoint, path) {
        let url = endpoint;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            url = 'http://' + url;
        }
        if (!url.endsWith(path)) {
            url = url + (path.startsWith('/') ? path : '/' + path);
        }
        return url;
    }
    logExporter() {
        return this.logExporterInstance;
    }
    metricReader() {
        return this.metricReaderInstance;
    }
    logProcessor() {
        return this.logProcessorInstance;
    }
    traceExporter() {
        return this.traceExporterInstance;
    }
    async forceFlush() {
        if (this.logProcessorInstance) {
            await this.logProcessorInstance.forceFlush();
        }
    }
    async shutdown() {
        try {
            await this.forceFlush();
        }
        catch (error) { }
        if (this.metricReaderInstance) {
            await this.metricReaderInstance.shutdown();
        }
        if (this.logProcessorInstance) {
            await this.logProcessorInstance.shutdown();
        }
    }
}
exports.OTLPExporter = OTLPExporter;
//# sourceMappingURL=otlp.js.map