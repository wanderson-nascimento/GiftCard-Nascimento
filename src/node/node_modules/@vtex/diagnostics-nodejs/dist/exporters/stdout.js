"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdoutExporter = void 0;
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const exporters_1 = require("../types/exporters");
class StdoutExporter {
    constructor(config) {
        this.config = config;
    }
    async initialize() {
        switch (this.config.telemetryType) {
            case exporters_1.TelemetryType.METRICS:
                await this.initializeMetrics();
                break;
            case exporters_1.TelemetryType.LOGS:
                await this.initializeLogs();
                break;
            case exporters_1.TelemetryType.TRACES:
                await this.initializeTraces();
                break;
            default:
                throw new Error(`Unsupported telemetry type: ${this.config.telemetryType}`);
        }
    }
    async initializeMetrics() {
        this.metricExporterInstance = new sdk_metrics_1.ConsoleMetricExporter();
        this.metricReaderInstance = new sdk_metrics_1.PeriodicExportingMetricReader({
            exporter: this.metricExporterInstance,
            exportIntervalMillis: (this.config.options?.interval || 3) * 1000
        });
    }
    async initializeLogs() {
        this.logExporterInstance = new sdk_logs_1.ConsoleLogRecordExporter();
        this.logProcessorInstance = new sdk_logs_1.SimpleLogRecordProcessor(this.logExporterInstance);
    }
    async initializeTraces() {
        this.traceExporterInstance = new sdk_trace_base_1.ConsoleSpanExporter();
    }
    async forceFlush() {
        if (this.logProcessorInstance) {
            await this.logProcessorInstance.forceFlush();
        }
    }
    logExporter() {
        return this.logExporterInstance;
    }
    metricReader() {
        return this.metricReaderInstance;
    }
    logProcessor() {
        return this.logProcessorInstance;
    }
    traceExporter() {
        return this.traceExporterInstance;
    }
    async shutdown() {
        try {
            await this.forceFlush();
        }
        catch (error) { }
        if (this.metricReaderInstance) {
            await this.metricReaderInstance.shutdown();
        }
        if (this.logProcessorInstance) {
            await this.logProcessorInstance.shutdown();
        }
    }
}
exports.StdoutExporter = StdoutExporter;
//# sourceMappingURL=stdout.js.map