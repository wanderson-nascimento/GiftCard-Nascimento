"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VtexAttributesLogProcessor = void 0;
const api_1 = require("@opentelemetry/api");
const constants_1 = require("./constants");
class VtexAttributesLogProcessor {
    constructor(nextProcessor) {
        this._nextProcessor = nextProcessor;
    }
    async onEmit(logRecord, context) {
        if (this._nextProcessor) {
            await this._nextProcessor.onEmit(logRecord, context);
        }
        const baggage = api_1.propagation.getBaggage(context);
        if (baggage) {
            baggage.getAllEntries().forEach(([key, entry]) => {
                const semanticKey = this.getSemanticKeyForBaggage(key);
                logRecord.setAttribute(semanticKey, entry.value);
            });
        }
        this.enrichWithHttpContext(logRecord);
    }
    getSemanticKeyForBaggage(key) {
        switch (key) {
            case 'vtex.operation.id':
                return constants_1.AttributeKeys.VTEX_OPERATION_ID;
            case 'vtex.account.name':
                return constants_1.AttributeKeys.VTEX_ACCOUNT_NAME;
            case 'vtex.identity.user.id':
                return constants_1.AttributeKeys.VTEX_IDENTITY_USER_ID;
            case 'vtex.user_agent':
                return constants_1.AttributeKeys.VTEX_USER_AGENT;
            default:
                return key;
        }
    }
    enrichWithHttpContext(logRecord) {
        const httpMethod = this.getAttributeValue(logRecord, 'http.method');
        if (httpMethod) {
            logRecord.setAttribute(constants_1.AttributeKeys.HTTP_METHOD, httpMethod);
        }
        const httpUrl = this.getAttributeValue(logRecord, 'http.url');
        if (httpUrl) {
            logRecord.setAttribute(constants_1.AttributeKeys.HTTP_URL, httpUrl);
        }
        const statusCode = this.getAttributeValue(logRecord, 'http.status_code');
        if (statusCode) {
            const statusCodeNumber = Number(statusCode);
            if (!isNaN(statusCodeNumber)) {
                logRecord.setAttribute(constants_1.AttributeKeys.HTTP_STATUS_CODE, statusCodeNumber);
                if (statusCodeNumber >= 500) {
                    logRecord.setAttribute(constants_1.AttributeKeys.ERROR, true);
                }
            }
        }
        const errorAttr = this.getAttributeValue(logRecord, 'error');
        if (errorAttr && errorAttr !== 'false' && errorAttr !== '0') {
            logRecord.setAttribute(constants_1.AttributeKeys.ERROR, true);
        }
    }
    getAttributeValue(logRecord, attributeName) {
        if (!logRecord.attributes) {
            return undefined;
        }
        const attr = logRecord.attributes[attributeName];
        if (attr === undefined || attr === null) {
            return undefined;
        }
        return String(attr);
    }
    async shutdown() {
        if (this._nextProcessor) {
            await this._nextProcessor.shutdown();
        }
    }
    async forceFlush() {
        if (this._nextProcessor) {
            await this._nextProcessor.forceFlush();
        }
    }
}
exports.VtexAttributesLogProcessor = VtexAttributesLogProcessor;
//# sourceMappingURL=log-processor.js.map