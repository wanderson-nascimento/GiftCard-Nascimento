"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedSampler = void 0;
exports.newComposedSampler = newComposedSampler;
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const traces_1 = require("../../types/traces");
const metadata_1 = require("./metadata");
class ComposedSampler {
    constructor(mode, samplers) {
        this.samplers = samplers;
        this.mode = mode;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const metadata = (0, metadata_1.newSamplerMetadata)('composed');
        metadata.extra['mode'] = this.mode;
        if (this.samplers.length === 0) {
            metadata.decision = 'drop';
            metadata.reason = 'no_samplers';
            return {
                decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
                attributes: metadata.toAttributes()
            };
        }
        for (const sampler of this.samplers) {
            const result = sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            if (result.attributes) {
                for (const [key, value] of Object.entries(result.attributes)) {
                    if (key.startsWith('sampler.')) {
                        if (key.includes('rate') || key.includes('account')) {
                            metadata.extra[key.substring(8)] = String(value);
                        }
                    }
                }
            }
            if (result.decision === sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED) {
                if (this.mode === traces_1.CompositionMode.SampleIfAny) {
                    metadata.decision = 'record_and_sample';
                    metadata.reason = `sampled_by_${sampler.toString()}`;
                    return {
                        decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                        attributes: metadata.toAttributes()
                    };
                }
            }
            else if (this.mode === traces_1.CompositionMode.SampleIfAll) {
                metadata.decision = 'drop';
                metadata.reason = `rejected_by_${sampler.toString()}`;
                return {
                    decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
                    attributes: metadata.toAttributes()
                };
            }
        }
        if (this.mode === traces_1.CompositionMode.SampleIfAll) {
            metadata.decision = 'record_and_sample';
            metadata.reason = 'all_samplers_accepted';
            return {
                decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                attributes: metadata.toAttributes()
            };
        }
        metadata.decision = 'drop';
        metadata.reason = 'no_sampler_accepted';
        return {
            decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
            attributes: metadata.toAttributes()
        };
    }
    toString() {
        return `ComposedSampler(mode=${this.mode})`;
    }
}
exports.ComposedSampler = ComposedSampler;
function newComposedSampler(mode, ...samplers) {
    return new ComposedSampler(mode, samplers);
}
//# sourceMappingURL=composed.js.map