"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VtexAccountSampler = void 0;
exports.newVtexAccountSampler = newVtexAccountSampler;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const metadata_1 = require("./metadata");
class VtexAccountSampler {
    constructor(provider) {
        this.accountAttributeKey = 'vtex.account.name';
        this.provider = provider;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const metadata = (0, metadata_1.newSamplerMetadata)('vtex_account');
        const parentContext = api_1.trace.getSpanContext(context);
        if (parentContext?.traceFlags && (parentContext.traceFlags & 1)) {
            metadata.decision = 'record_and_sample';
            metadata.reason = 'parent_sampled';
            return {
                decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                attributes: metadata.toAttributes()
            };
        }
        let accountId = '';
        if (attributes[this.accountAttributeKey]) {
            accountId = String(attributes[this.accountAttributeKey]);
        }
        if (!accountId) {
            const defaultRate = this.provider.getDefaultRate();
            metadata.extra['account'] = 'default';
            metadata.extra['rate'] = defaultRate.toFixed(4);
            return this.sampleByRate(traceId, defaultRate, 'default', metadata);
        }
        const [rate, exists] = this.provider.getSamplingRate(accountId);
        metadata.extra['account'] = accountId;
        metadata.extra['rate'] = rate.toFixed(4);
        metadata.extra['configured'] = exists ? 'true' : 'false';
        return this.sampleByRate(traceId, rate, accountId, metadata);
    }
    sampleByRate(traceId, rate, accountId, metadata) {
        const hashHex = traceId.substring(0, 8);
        const hashValue = parseInt(hashHex, 16);
        const normalizedValue = hashValue / 0xFFFFFFFF;
        if (rate >= 1.0) {
            metadata.decision = 'record_and_sample';
            metadata.reason = 'full_sampling';
            return {
                decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                attributes: metadata.toAttributes()
            };
        }
        if (normalizedValue < rate) {
            metadata.decision = 'record_and_sample';
            metadata.reason = 'rate_based';
            return {
                decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                attributes: metadata.toAttributes()
            };
        }
        metadata.decision = 'drop';
        metadata.reason = 'rate_based';
        return {
            decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
            attributes: metadata.toAttributes()
        };
    }
    toString() {
        return 'VtexAccountSampler';
    }
}
exports.VtexAccountSampler = VtexAccountSampler;
function newVtexAccountSampler(provider) {
    return new VtexAccountSampler(provider);
}
//# sourceMappingURL=vtex-account.js.map