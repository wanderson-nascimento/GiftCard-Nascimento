"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewClient = exports.TraceClientImpl = void 0;
const api_1 = require("@opentelemetry/api");
const common_1 = require("../types/common");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const span_1 = require("./span");
const exporters_1 = require("../exporters");
const instrumentation_1 = require("../instrumentation");
const utils_1 = require("../utils");
const tracesClientConfigDefaults = {
    setGlobalProvider: false,
    useSimpleProcessor: false,
    batchSize: 512,
    flushIntervalMs: 5000,
    timeoutMillis: 30000,
    maxQueueSize: 2048,
    processors: [],
    instrumentations: []
};
class TraceClientImpl {
    constructor(config, serviceName, clientName) {
        config = { ...tracesClientConfigDefaults, ...config };
        if (!serviceName) {
            throw new Error('Service name is required');
        }
        const resource = config.resource || (0, utils_1.createResource)({
            [semantic_conventions_1.ATTR_SERVICE_NAME]: serviceName,
        });
        if (!config?.provider) {
            config.provider = new sdk_trace_node_1.NodeTracerProvider({
                resource: resource,
                sampler: config.sampler
            });
        }
        this.tracerProvider = config.provider;
        this.exporter = config.exporter;
        this.standardPropagator = (0, instrumentation_1.createCompositePropagator)();
        try {
            const batchProcessorOptions = {
                maxExportBatchSize: config.batchSize || 512,
                scheduledDelayMillis: config.flushIntervalMs || 5000,
                exportTimeoutMillis: config.timeoutMillis || 30000,
                maxQueueSize: config.maxQueueSize || 2048
            };
            const batchProcessor = new sdk_trace_base_1.BatchSpanProcessor(this.exporter.traceExporter(), batchProcessorOptions);
            const spanProcessors = [batchProcessor];
            if (config.useSimpleProcessor) {
                const simpleProcessor = new sdk_trace_base_1.SimpleSpanProcessor(this.exporter.traceExporter());
                spanProcessors.push(simpleProcessor);
            }
            if (config.processors && Array.isArray(config.processors)) {
                spanProcessors.push(...config.processors);
            }
            const tracerConfig = {
                resource: resource,
                sampler: config.sampler,
                spanProcessors: spanProcessors
            };
            this.tracerProvider = new sdk_trace_node_1.NodeTracerProvider(tracerConfig);
            if (config.setGlobalPropagator === true || config.setGlobalProvider) {
                api_1.propagation.setGlobalPropagator(this.standardPropagator);
            }
            if (config.instrumentations && Array.isArray(config.instrumentations) && config.instrumentations.length > 0) {
                for (const instrumentation of config.instrumentations) {
                    instrumentation(this.tracerProvider);
                }
            }
            if (config.setGlobalProvider) {
                api_1.trace.setGlobalTracerProvider(this.tracerProvider);
                this.tracerProvider.register();
            }
            else {
                this.tracerProvider.register();
            }
            this.otelTracer = this.tracerProvider.getTracer(clientName);
        }
        catch (error) {
            throw error;
        }
    }
    startSpan(name, options) {
        const otelSpanOptions = {
            attributes: options?.attributes || {}
        };
        if (options?.kind) {
            otelSpanOptions.kind = options.kind;
        }
        if (options?.timestamp) {
            otelSpanOptions.startTime = options.timestamp;
        }
        const otelSpan = this.otelTracer.startSpan(name, otelSpanOptions);
        return new span_1.Span(otelSpan, name, options?.kind || common_1.SpanKind.INTERNAL);
    }
    endSpan(span) {
        span.end();
    }
    getProvider() {
        return this.tracerProvider;
    }
    getPropagator() {
        return this.standardPropagator;
    }
    inject(headers, ctx) {
        const propagator = this.getPropagator();
        if (propagator) {
            const contextToUse = ctx || api_1.context.active();
            propagator.inject(contextToUse, headers, {
                set: (carrier, key, value) => {
                    carrier[key] = value;
                }
            });
        }
    }
    extract(headers) {
        const propagator = this.getPropagator();
        let extractedContext;
        if (propagator) {
            const activeContext = api_1.context.active();
            extractedContext = propagator.extract(activeContext, headers, {
                get: (carrier, key) => carrier[key],
                keys: (carrier) => Object.keys(carrier)
            });
        }
        else {
            extractedContext = api_1.context.active();
        }
        // Converter para EnhancedContext e adicionar o mÃ©todo execute
        const enhancedContext = extractedContext;
        enhancedContext.execute = (callback) => api_1.context.with(extractedContext, callback);
        return enhancedContext;
    }
    getContext() {
        return api_1.context.active();
    }
    getActiveSpan() {
        return api_1.trace.getSpan(api_1.context.active());
    }
    async shutdown() {
        await this.tracerProvider.shutdown();
        await this.exporter.shutdown();
    }
}
exports.TraceClientImpl = TraceClientImpl;
const NewClient = (config, serviceName, clientName) => {
    if (!config.exporter) {
        const stdoutconfig = (0, exporters_1.CreateTracesExporterConfig)({ endpoint: 'stdout' });
        config.exporter = (0, exporters_1.CreateExporter)(stdoutconfig, 'stdout');
    }
    config.exporter.initialize();
    return new TraceClientImpl(config, serviceName, clientName);
};
exports.NewClient = NewClient;
//# sourceMappingURL=client.js.map