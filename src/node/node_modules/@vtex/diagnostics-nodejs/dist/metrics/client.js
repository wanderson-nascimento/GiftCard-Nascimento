"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsClientImpl = void 0;
exports.NewClient = NewClient;
const api_1 = require("@opentelemetry/api");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const options_1 = require("./options");
const counter_1 = require("./counter");
const gauge_1 = require("./gauge");
const histogram_1 = require("./histogram");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const exporters_1 = require("../exporters");
const utils_1 = require("../utils");
class MetricsClientImpl {
    constructor(config, serviceName, clientName) {
        if (!serviceName) {
            throw new Error('Service name is required');
        }
        const resource = config.resource || (0, utils_1.createResource)({
            [semantic_conventions_1.ATTR_SERVICE_NAME]: serviceName,
        });
        if (!config.provider) {
            const providerOptions = {
                resource: resource
            };
            if (config.views && config.views.length > 0) {
                providerOptions.views = config.views;
            }
            this.providerInstance = new sdk_metrics_1.MeterProvider(providerOptions);
        }
        else {
            this.providerInstance = config.provider;
        }
        if (config.exporter?.metricReader()) {
            this.providerInstance = new sdk_metrics_1.MeterProvider({
                resource: resource,
                readers: [config.exporter.metricReader()],
            });
        }
        if (config.setGlobalProvider) {
            api_1.metrics.setGlobalMeterProvider(this.providerInstance);
        }
        this.meterInstance = this.providerInstance.getMeter(clientName);
    }
    meter() {
        return this.meterInstance;
    }
    provider() {
        return this.providerInstance;
    }
    counter(name, opts = []) {
        return (0, counter_1.NewCounter)(this.meterInstance, name, opts);
    }
    gauge(name, opts = []) {
        return (0, gauge_1.NewGauge)(this.meterInstance, name, opts);
    }
    histogram(name, opts = []) {
        return (0, histogram_1.NewHistogram)(this.meterInstance, name, opts);
    }
    createMetric(metricType, name, options) {
        const opts = [];
        if (options?.description)
            opts.push((0, options_1.WithDescription)(options.description));
        if (options?.unit)
            opts.push((0, options_1.WithUnit)(options.unit));
        if (metricType === 'histogram' && (options?.boundaries || options?.buckets)) {
            const buckets = options?.boundaries || options?.buckets;
            if (Array.isArray(buckets)) {
                opts.push((0, options_1.WithBuckets)(buckets));
            }
        }
        switch (metricType) {
            case 'counter': return this.counter(name, opts);
            case 'gauge': return this.gauge(name, opts);
            case 'histogram': return this.histogram(name, opts);
            default: throw new Error(`Unknown metric type: ${metricType}`);
        }
    }
    createCounter(name, options) {
        return this.createMetric('counter', name, options);
    }
    createGauge(name, options) {
        return this.createMetric('gauge', name, options);
    }
    createHistogram(name, options) {
        return this.createMetric('histogram', name, options);
    }
    getProvider() {
        return this.providerInstance;
    }
    async shutdown() {
        if (this.providerInstance) {
            await this.providerInstance.shutdown();
        }
    }
}
exports.MetricsClientImpl = MetricsClientImpl;
async function NewClient(config, serviceName, clientName) {
    if (!config.exporter) {
        const stdoutconfig = (0, exporters_1.CreateMetricsExporterConfig)({ endpoint: 'stdout' });
        config.exporter = (0, exporters_1.CreateExporter)(stdoutconfig, 'stdout');
    }
    await config.exporter.initialize();
    return new MetricsClientImpl(config, serviceName, clientName);
}
//# sourceMappingURL=client.js.map